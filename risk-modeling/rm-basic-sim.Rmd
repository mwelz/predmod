---
title: "Basic Risk Modeling Simulation"
author: "mwelz"
date: "6/21/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Introduction
The idea is to generate a very simple simulation setup. If the risk modeling fails here, it will also fail in more complex setups.

We first load and define some helper functions.

```{r}
rm(list = ls()) ; cat("\014")

# load the helper functions
source(paste0(getwd(), "/rm-funs/rm-funs.R"))

# define the logistic function
logistic <- function(x){1 / (1 + exp(-x))}
```

## Data Generation

We first define the sample size to $n = 10,000$ and draw $p = 5$ independent zero-mean covariates from the multivariate normal distribution. We also define a constant factor `tau` that is the basis of the average treatment effect and randomly draw a treatment assignment `w` to emulate an RCT.

```{r}
set.seed(1)
n <- 10000
p <- 5

# treatment assignment (assume RCT)
w <- rbinom(n, 1, 0.5) 

# true treatment effect
tau <- -2

# covariates
x <- mvtnorm::rmvnorm(n, mean = rep(0, p), sigma = diag(p))
```

Next, we define coefficients `theta` and define the process that generates scores with and without the treatment effect as follows:

$$ z_i(1) = \tau + \mathbf{z}_i^\top \theta + \varepsilon_i$$
$$ z_i(0) = \mathbf{z}_i^\top \theta + \varepsilon_i$$

We then transform these scores to probabilities and use these probabilities to draw the binary outcome from a binomial distribution. We then use treatment asisgnment `w` to make sure that there is only one outcome `y` (the observed outcome) for each individual. The bottom line of this data generating process is that data is generated linearly and the influence of the treatment is constant. Hence, this setup is the easiest setup possible.


```{r}
# coefficients (including an intercept)
theta <- c(0.2, 0.5, -0.3, 0.7, -0.1, 0.4)

# compute Pr(Y = 1 | X) for each individual (with noise)
eps <-  rnorm(n, mean = 0, sd = 0.5)
pi1 <- logistic(tau + as.numeric(cbind(1, x) %*% theta) + eps)
pi0 <- logistic(as.numeric(cbind(1, x) %*% theta) + eps)
hte <- pi1 - pi0

# true ATE
ate <- mean(pi1) - mean(pi0)

# create binary outcomes. Equals 1 if individual died.
y0 <- rbinom(n, 1, pi0)
y1 <- rbinom(n, 1, pi1)
y  <- ifelse(w == 1, y1, y0) # observed outcome
```

## Analysis

We first run a sanity check to verify that we can obtain an accurate estimate of the ATE by taking the difference of average mortality within each group. 

```{r}
# sanity check 
ate.hat <- mean(y[w==1]) - mean(y[w==0])
ate.hat - ate # accurate estimation!
```

Then we perform risk modeling.

```{r}
# risk modeling
risk.model <- risk.modeling(X = x, w = w, y = y, alpha = 1, offset.lp = TRUE)

# histogram of predicted benefit
hist(risk.model$predicted.benefit, main = "Histogram of Predicted Benefit", xlab = "Predicted Benefit")

# calibration plot with the 4 quartiles
calibration.plot(risk.model)

# c index (based on second stage risk probabilities)
risk    <- transform.to.probability(risk.model$risk.regular.w)
c.index <- Hmisc::rcorr.cens(risk, y)[1]
c.index
```

