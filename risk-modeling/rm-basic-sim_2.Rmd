---
title: "Basic Risk Modeling Simulation: general LRM"
author: "ktenhaaf"
date: "6/23/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Introduction
The idea is to generate a very simple simulation setup. If the risk modeling fails here, it will also fail in more complex setups.

We first load and define some helper functions.

```{r}
rm(list = ls()) ; cat("\014")

# load the helper functions
source(paste0(getwd(), "/rm-funs/rm-funs.R"))

# define the logistic function
logistic <- function(x){1 / (1 + exp(-x))}
```

## Data Generation

We first define the sample size to $n = 10,000$ and draw $p = 5$ independent zero-mean covariates from the multivariate normal distribution. We also define a constant factor `tau` that is the basis of the average treatment effect and randomly draw a treatment assignment `w` to emulate an RCT.

```{r}
set.seed(1)
n <- 10000
p <- 5

# treatment assignment (assume RCT)
w <- rbinom(n, 1, 0.5) 

# true treatment effect parameter
tau <- -2

# covariates
x <- mvtnorm::rmvnorm(n, mean = rep(0, p), sigma = diag(p))
```

Next, we define coefficients `theta` and define the process that generates scores with and without the treatment effect as follows:

$$ z_i(1) = \tau + \mathbf{z}_i^\top \theta + \varepsilon_i$$
$$ z_i(0) = \mathbf{z}_i^\top \theta + \varepsilon_i$$

We then transform these scores to probabilities and use these probabilities to draw the binary outcome from a binomial distribution. We then use treatment asisgnment `w` to make sure that there is only one outcome `y` (the observed outcome) for each individual. The bottom line of this data generating process is that data is generated linearly and the influence of the treatment is constant. Hence, this setup is the easiest setup possible.


```{r}
# coefficients (including an intercept)
theta <- c(0.2, 0.5, -0.3, 0.7, -0.1, 0.4)

# compute Pr(Y = 1 | X) for each individual (with noise)
eps <-  rnorm(n, mean = 0, sd = 0.5)
pi1 <- logistic(tau + as.numeric(cbind(1, x) %*% theta) + eps)
pi0 <- logistic(as.numeric(cbind(1, x) %*% theta) + eps)
hte <- pi1 - pi0

# true ATE
ate <- mean(pi1) - mean(pi0)
ate 

# create binary outcomes. Equals 1 if individual died.
y0 <- rbinom(n, 1, pi0)
y1 <- rbinom(n, 1, pi1)
y  <- ifelse(w == 1, y1, y0) # observed outcome
```

## Analysis

We first run a sanity check to verify that we can obtain an accurate estimate of the ATE by taking the difference of average mortality within each group. 

```{r}
# sanity check 
ate.hat <- mean(y[w==1]) - mean(y[w==0])
ate.hat - ate # accurate estimation!
```

Then we perform risk modeling.

```{r}
#quick linear model: equation #1 in Rekkas
library(rms)
fit = lrm(y~x, x=TRUE,y=TRUE)
fit$coefficients 

#coefficient seem to have the right direction
p <- predict(fit) #linear predictor from equation #1

#Now fit equation #2; trying to figure out how to add an offset in LRM
fit_treat = lrm(y~w+p)
fit_treat$coefficients #coefficient for W is close to -2 (-1.91)

#fit_treat2 = lrm.fit(y,w, offset=p)
fit_treat_predict = predict(fit_treat)
data=data.frame(fit_treat_predict,w,y,p)
ate.hat_alt <- mean(data$fit_treat[data$w==1]) - mean(data$fit_treat[data$w==0]) 
ate.hat_alt
#ATE is close to parameter of W
quantile.groups <- quantile.group(p, c(0.25,0.5,0.75,1))
data=data.frame(fit_treat_predict,w,y,p,quantile.groups)

## calculate observed benefit and predicted benefit for each quantile group
  # initialize
  obs.ben.mat           <- as.data.frame(matrix(NA, ncol(quantile.groups), 4))
  colnames(obs.ben.mat) <- c("quantile", "mean", "stderr", "df")
  obs.ben.mat$quantile  <- gsub(" .*$", "", colnames(quantile.groups))
  pred.ben.mat          <- obs.ben.mat

  for(i in 1:ncol(quantile.groups)){
    group <- quantile.groups[,i]
    
    ## observed benefit
    # corresponds to difference in mean(y[group & W=w])
    x1                        <- data[quantile.groups & w == 1]
    x2                        <- data[quantile.groups & w == 0]
    ttest                     <- t.test(x1, x2)
    obs.ben.mat[i, "mean"]    <- unname(ttest$estimate[1] - ttest$estimate[2])
    obs.ben.mat[i, "stderr"]  <- unname(ttest$stderr)
    obs.ben.mat[i, "df"]      <- unname(ttest$parameter)
    
    ## group by predicted benefit
    pred.ben.mat[i, "mean"]   <- mean(pred.ben[group])
    pred.ben.mat[i, "stderr"] <- sqrt(var(pred.ben[group]) / sum(group))
    pred.ben.mat[i, "df"]     <- sum(group) - 1
  }


```

